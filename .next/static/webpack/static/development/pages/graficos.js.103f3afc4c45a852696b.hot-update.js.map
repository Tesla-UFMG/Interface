{"version":3,"file":"static/webpack/static\\development\\pages\\graficos.js.103f3afc4c45a852696b.hot-update.js","sources":["webpack:///./pages/graficos.js"],"sourcesContent":["import React, { Component } from 'react'\r\nimport DataFetcher from '../components/data-fetcher.js'\r\n\r\n\r\nimport { LineChart, Line, CartesianGrid, XAxis, YAxis, Legend, ResponsiveContainer, Label } from 'recharts';\r\n\r\n\r\nimport {DelayContext} from '../components/contexts.js';\r\nimport {availablePlotOptions, persistanceTimeout, pointsPerSecond} from '../components/constants.js';\r\nimport ECU from \"../components/ecu.js\";\r\n\r\n\r\nconst DelayProvider = DelayContext.Provider;\r\n\r\n\r\nvar i = 1;\r\n\r\n\r\nclass Graficos extends DataFetcher {\r\n\r\n    constructor(props) {\r\n        super(props)\r\n\r\n        this.delay = 1000/pointsPerSecond;\r\n        this.rootPage = \"plot/\"\r\n        this.page = \"\"\r\n\r\n        this.state.plotData = [{name: 'Page 0', value: Math.random()*100}];\r\n        this.state.data = [];\r\n\r\n        this.generateData = this.generateData.bind(this);\r\n\r\n        this.dado1Change = this.dado1Change.bind(this);\r\n        this.dado2Change = this.dado2Change.bind(this);\r\n        this.buildPage = this.buildPage.bind(this);\r\n\r\n        this.state.dado1 = \"null\";\r\n        this.state.dado2 = \"null\";\r\n        this.shouldFetch = true;\r\n\r\n        this.lastTimestamps = [0, 0];\r\n        this.lastData = [];\r\n\r\n        this.lastMergedTimestamps = [0, 0];\r\n        this.lastMergedData = [];\r\n\r\n        this.mappedPlotingFields = {};\r\n\r\n        this.mapPlotFields();\r\n        \r\n\r\n        // this.itemsPerFetch = persistanceTimeout/1000 * receivePerSecond;\r\n        // this.actualPerSecond = this.itemsPerFetch / persistanceTimeout/10000;\r\n        // this.reduceRatio = parseInt(receivePerSecond / pointsPerSecond);\r\n    }\r\n\r\n    async mapPlotFields() {\r\n        this.mappedPlotingFields = availablePlotOptions.reduce((obj, item, index) => (obj[item.index] = index, obj), {});\r\n    }\r\n\r\n    generateData() {\r\n        var prototype = {name: 'Page '+i, value: Math.random()*100}\r\n        i++;\r\n        var data = this.state.plotData;\r\n        data.push(prototype);\r\n        // console.log(data);\r\n        this.setState({plotData: data});\r\n    }\r\n\r\n    componentDidMount() {\r\n        super.componentDidMount();\r\n        this.stopFetching();\r\n        super.doFetch();\r\n        // this.shouldFetch = true;\r\n        // console.log(\"child did mount\");\r\n        // this.grTimer = setInterval(this.generateData, 1000);\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        super.componentWillUnmount();\r\n        // clearInterval(this.grTimer);\r\n    }\r\n\r\n    dado1Change(event) {\r\n        console.log(\"dado 1 changed\")\r\n        const id = event.target.value;\r\n        // debugger;\r\n        this.setState({dado1: id}, this.buildPage);\r\n\r\n        this.lastTimestamps[0] = 0;\r\n        this.lastData[0] = [];\r\n        this.lastMergedData = [];\r\n        this.lastMergedTimestamps[0] = 0;\r\n\r\n        // this.resetData();\r\n    }\r\n\r\n    dado2Change(event) {\r\n        console.log(\"dado 2 changed\")\r\n        const id =  event.target.value;\r\n        this.setState({dado2: id}, this.buildPage);\r\n        // this.resetData();\r\n\r\n        this.lastTimestamps[1] = 0;\r\n        this.lastData[1] = [];\r\n        this.lastMergedData = [];\r\n        this.lastMergedTimestamps[1] = 0;\r\n    }\r\n\r\n    resetData() {\r\n        \r\n        \r\n    }\r\n\r\n    gaugeFrequency(filteredValues) {\r\n\r\n        const iterationBasis = 20;\r\n        const iterationQuan = (filteredValues.length-1 < iterationBasis ? filteredValues.length-1 : iterationBasis);\r\n    \r\n        // debugger;\r\n        //calcula frequência de recebimento a partir dos primeiros iterationQuan itens, isso para definir a razão de redução\r\n        let sumDiff1 = 0;\r\n        for (var freqI = 0; freqI < iterationQuan-1; freqI++) {\r\n            const diff1 = (filteredValues[freqI+1].timestamp-filteredValues[freqI].timestamp);\r\n            sumDiff1 += diff1;\r\n        }\r\n        let sumDiff2 = 0;\r\n        for (var freqI = filteredValues.length-1; freqI > filteredValues.length-iterationQuan-1; freqI--) {\r\n            const diff2 = (filteredValues[freqI].timestamp-filteredValues[freqI-1].timestamp);\r\n            sumDiff2 += diff2;\r\n        }\r\n        const afferedFrequency = 1000/((sumDiff1+sumDiff2)/(2*(iterationQuan-1)));\r\n\r\n        const rat = parseInt(afferedFrequency / pointsPerSecond);\r\n\r\n        const lastRatio = this.reduceRatio;\r\n\r\n        //trava a redução em 1\r\n        const newRatio = (rat > 1 ? rat : 1);\r\n\r\n        //só se tiver um erro menor de 50% da última aferição, usa a nova aferição\r\n        if (Math.abs(newRatio - lastRatio) < lastRatio*0.5) {\r\n            this.reduceRatio = newRatio;\r\n        //senao, calcula a frequencia novamente so que com todos os componentes\r\n        } else {\r\n            let sumDiff = 0;\r\n            for (var freqI = 0; freqI < filteredValues.length-1; freqI++) {\r\n                const diff = (filteredValues[freqI+1].timestamp-filteredValues[freqI].timestamp);\r\n                sumDiff += diff;\r\n            }\r\n            const averageFreq = 1000/(sumDiff/(filteredValues.length-1));\r\n            // debugger;\r\n            const rat = parseInt(averageFreq / pointsPerSecond);\r\n\r\n            //trava a redução em 1\r\n            this.reduceRatio = (rat > 1 ? rat : 1);\r\n\r\n        }\r\n\r\n        console.log(\"Reduce ratio: \"+this.reduceRatio);\r\n    }\r\n\r\n    treatData(data) {\r\n        const actualDate = new Date().getTime();\r\n        \r\n        const compareFunction = (a, b) => a.timestamp - b.timestamp;\r\n        const limitDate = new Date().getTime() - persistanceTimeout;\r\n\r\n        var keys = [];\r\n\r\n        // debugger;\r\n\r\n\r\n        const lastMergedTimes = this.lastMergedTimestamps.slice(0);\r\n\r\n        for (const key of Object.keys(data)) {\r\n            if (isNaN(key)) continue;\r\n            \r\n            //TALVEZ N SEJA NECESSARIO\r\n            let filteredValues = data[key].filter(entry => entry.timestamp >= limitDate);\r\n\r\n\r\n            \r\n            const lastTimestamp = this.lastTimestamps[keys.length];\r\n            \r\n            filteredValues.sort(compareFunction);\r\n\r\n            this.lastTimestamps[keys.length] = filteredValues[filteredValues.length-1].timestamp;\r\n\r\n\r\n\r\n\r\n            \r\n            // debugger;\r\n\r\n\r\n            this.gaugeFrequency(filteredValues);\r\n\r\n            // const contIndex = filteredValues.findIndex(value => value.timestamp == lastTimestamp.crude);\r\n            \r\n\r\n            let newValues = []\r\n            \r\n            // debugger;\r\n\r\n            let breakFlag = false;\r\n            for(var j = filteredValues.length-1; j >= 0; j-=this.reduceRatio) {\r\n                \r\n                let v = Object.assign({},filteredValues[j]);\r\n                // let sTime = 0, sVal = 0;\r\n                // for (var k = 0; k < quanT; k++) {\r\n                //     if (j+k >= filteredValues.length) break;\r\n                //     sTime += filteredValues[j+k].timestamp;\r\n                //     sVal += parseFloat(filteredValues[j+k].value);\r\n                // }\r\n                // v.value = sVal/k;\r\n                // v.timestamp = sTime/k;\r\n                // newValues.push(v);\r\n                let sTime = 0, sVal = 0;\r\n                let summedQuan = 0;\r\n                for (var k = 0; k < this.reduceRatio; k++) {\r\n                    if (j-k < 0) break;\r\n                    if (filteredValues[j-k].timestamp == lastTimestamp) {\r\n                        breakFlag = true;\r\n                        if (k != 0) {\r\n                            let el = newValues.pop();\r\n                            sVal += el.value*this.reduceRatio;\r\n                            sTime += el.timestamp*this.reduceRatio;\r\n                            summedQuan += this.reduceRatio\r\n                        }\r\n                        break;\r\n                    }\r\n                    // if (filteredValues[j-k].value > sVal) sVal = filteredValues[j-k].value;\r\n                    sVal += parseFloat(filteredValues[j-k].value);\r\n                    sTime += filteredValues[j-k].timestamp;\r\n                    summedQuan++;\r\n                    // sVal += parseFloat(filteredValues[j+k].value);\r\n                }\r\n                //se a proxima iteração não conseguir agrupar reduceRatio elementos, entao agrupa eles na atual. isso reduz picos no grafico\r\n                // if (!breakFlag && (j-k-this.reduceRatio < 0)) {\r\n                //     j-=this.reduceRatio;\r\n                //     summedQuan = 0;\r\n                //     for (let k2 = 0; k2 < this.reduceRatio; k2++) {\r\n                //         if (j-k2 < 0) break;\r\n                //         if (filteredValues[j-k2].timestamp == lastTimestamp) {\r\n                //             breakFlag = true;\r\n                //             break;\r\n                //         }\r\n                //         // if (filteredValues[j-k].value > sVal) sVal = filteredValues[j-k].value;\r\n                //         sVal += parseFloat(filteredValues[j-k2].value);\r\n                //         sTime += filteredValues[j-k2].timestamp;\r\n                //         summedQuan++;\r\n                //         // sVal += parseFloat(filteredValues[j+k].value);\r\n                //     }\r\n                // }\r\n                if (sTime != 0) {\r\n                    v.value = sVal/summedQuan;\r\n                    v.timestamp = sTime/summedQuan;\r\n                    newValues.push(v);\r\n                }\r\n                if (breakFlag) break;\r\n            }\r\n\r\n            newValues = newValues.reverse();            \r\n            // debugger;\r\n\r\n\r\n            //GUARDA OS TIMESTAMPS JA FORMATADOS PARA DEPOIS AFERIR ONDE PARAR NO AGRUPAMENTO\r\n            //TODO: TRAVANDO (DANDO UNDEFINED), CONSERTAR\r\n            if (typeof newValues[newValues.length-1].timestamp == 'undefined')\r\n                debugger;\r\n            this.lastMergedTimestamps[keys.length] = newValues[newValues.length-1].timestamp;\r\n            \r\n            \r\n\r\n            //se setado, entao encotrou um timestamp igual ao ultimo timestamp. entao reaproveita os ultimos dados\r\n            if (breakFlag) {\r\n                // debugger;\r\n                const fromIndex = this.lastData[keys.length].findIndex(value => value.timestamp >= actualDate-persistanceTimeout);\r\n                \r\n                let lastDataPart = this.lastData[keys.length].slice(fromIndex);\r\n                newValues = lastDataPart.concat(newValues);\r\n            }\r\n\r\n            this.lastData[keys.length] = newValues;\r\n\r\n            \r\n            // debugger;\r\n            \r\n            data[key] = newValues;\r\n            \r\n            \r\n            i++;\r\n            keys.push(key);\r\n        }\r\n\r\n        // const newData = Object.entries(data).map(\r\n        //     ([key, value]) => value.sort(compareFunction)\r\n        // )\r\n        console.log(\"data treated\");\r\n\r\n        // debugger;\r\n\r\n        const merged = this.mergeData(data, keys, lastMergedTimes, actualDate);\r\n\r\n        return this.formatData(merged, actualDate, keys);\r\n    }\r\n\r\n\r\n\r\n    formatData(data, actualDate, keys){\r\n\r\n        const finalValue = data.map(value => {\r\n            let nValue = Object.assign({},value);\r\n            nValue.timestamp = -(actualDate - nValue.timestamp)/1000;\r\n\r\n            //formata o valor de acordo com a formatFn definida na constants.js\r\n            keys.forEach( key => nValue[key] = availablePlotOptions[this.mappedPlotingFields[key]].formatFn(nValue[key]) )\r\n            \r\n            return nValue;\r\n        }, this);\r\n\r\n        return finalValue;\r\n    }\r\n\r\n    mergeData(data, keys, lastMergedTimestamps, actualDate) {\r\n         if (keys.length == 1) {\r\n             let values = data[keys[0]];\r\n             \r\n             return values.map(element => {return {[element.field]: element.value, timestamp: element.timestamp}})\r\n         }\r\n             \r\n         \r\n\r\n        let component1 = data[keys[0]];\r\n        let component2 = data[keys[1]];\r\n\r\n        // debugger;\r\n        // console.log(component1.map(element => element.timestamp))\r\n        // console.log(component2.map(element => element.timestamp))\r\n\r\n        let size1 = component1.length;\r\n        let size2 = component2.length;\r\n\r\n        const buildNewValue = (value1, value2, keys) => {\r\n            return {\r\n                [keys[0]]: value1.value,\r\n                [keys[1]]: value2.value,\r\n                timestamp: (value1.timestamp+value2.timestamp)/2\r\n            }\r\n        }\r\n        var index1 = size1-1, index2 = size2-1;\r\n        let newData = [];\r\n        // debugger;\r\n        while(true) {\r\n\r\n            let value1 = component1[index1];\r\n            let value2 = component2[index2];\r\n\r\n            if (this.lastMergedData.length > 0 && (value1.timestamp == lastMergedTimestamps[0] || value2.timestamp == lastMergedTimestamps[1])) {\r\n                //cancela geração e pega do lastMergedData\r\n\r\n                const fromIndex = this.lastMergedData.findIndex(value => value.timestamp >= actualDate-persistanceTimeout);\r\n                \r\n                let lastDataPart = this.lastMergedData.slice(fromIndex);\r\n                newData = lastDataPart.concat(newData.reverse());\r\n\r\n                this.lastMergedData = newData;\r\n\r\n                break;\r\n            }\r\n\r\n            if (value1.timestamp < value2.timestamp) {\r\n                let difference = Math.abs(value2.timestamp-value1.timestamp);\r\n                while((index2-1 >= 0) && (Math.abs(component2[index2-1].timestamp-value1.timestamp) < difference)) {\r\n                    index2--;\r\n                    difference = Math.abs(component2[index2].timestamp-value1.timestamp)\r\n                }\r\n                newData.push(buildNewValue(value1, component2[index2], keys))\r\n            } else if (value1.timestamp > value2.timestamp) {\r\n                let difference = Math.abs(value2.timestamp-value1.timestamp);\r\n                while((index1-1 >= 0) && (Math.abs(component1[index1-1].timestamp-value2.timestamp) < difference)) {\r\n                    index1--;\r\n                    difference = Math.abs(component1[index1].timestamp-value2.timestamp)\r\n                }\r\n                newData.push(buildNewValue(component1[index1], value2, keys))\r\n            } else {\r\n                newData.push(buildNewValue(value1, value2, keys));\r\n            }\r\n\r\n            index1--;\r\n            index2--;\r\n\r\n            if (index2 < 0 || index1 < 0) break;\r\n\r\n        }\r\n\r\n        return newData;\r\n    }\r\n\r\n    buildPage() {\r\n        this.page = (this.state.dado1 != \"null\" ? \"?id=\"+this.state.dado1: \"\") + (this.state.dado2 != \"null\" ? \"&id=\"+this.state.dado2: \"\");\r\n        // debugger;\r\n        \r\n        this.startFetching();\r\n        // console.log(this.page);\r\n    }\r\n\r\n    render() {\r\n        // console.log(persistanceTimeout);\r\n        // console.log(this.state.data);\r\n        return(\r\n            <div className=\"container-fluid\">\r\n                <DelayProvider value={this.delay}>\r\n                    <form>\r\n                        <div className=\"row\">\r\n                            <div className=\"col-6\">\r\n                                <div className=\"d-flex justify-content-center align-items-center form-group dados-grafico\">\r\n                                    <div className=\"dado-grafico-title\">DADO 1:{\"  \"}</div>\r\n                                    <select value={this.state.dado1} className=\"form-control\" onChange={this.dado1Change}>\r\n                                        <option value=\"null\" defaultValue=\"selected\">Selecione</option>\r\n                                        {availablePlotOptions.map((value) =>\r\n                                            <option value={value.index}>{value.name}</option>\r\n                                        )}\r\n                                    </select>\r\n                                </div>\r\n                            </div>\r\n                            <div className=\"col-6\">\r\n                                <div className=\"d-flex justify-content-center align-items-center form-group dados-grafico\">\r\n                                    <div className=\"dado-grafico-title\">DADO 2:{\"  \"}</div>\r\n                                    <select value={this.state.dado2} className=\"form-control\" onChange={this.dado2Change}>\r\n                                        <option value=\"null\" selected=\"selected\">Selecione</option>\r\n                                        {this.state.dado1 != \"null\" && availablePlotOptions.map((value) => {\r\n                                                if (value.index != this.state.dado1) {\r\n                                                    return <option value={value.index}>{value.name}</option>\r\n                                                } else {\r\n                                                    return false;\r\n                                                }\r\n                                            }\r\n                                        )}\r\n                                    </select>\r\n                                </div>\r\n                            </div>\r\n                            \r\n                                \r\n                            \r\n                        </div>\r\n                    </form>\r\n                    <div className=\"row\">\r\n                        <div className=\"col-12\">\r\n                            <ResponsiveContainer minHeight=\"70vh\">\r\n                                <LineChart data={this.state.data} margin={{ top: 10, right: 15, bottom: 15, left: 15 }} key={Math.random()}>\r\n                                    {/* <Line type=\"monotone\" dataKey=\"value\" stroke=\"#F5F5F5\" strokeWidth={5} isAnimationActive={false} /> */}\r\n                                    <CartesianGrid stroke=\"#838383\" strokeDasharray=\"3 3\" />\r\n                                    <XAxis type=\"number\" dataKey=\"timestamp\">\r\n                                        <Label value=\"Tempo [s]\" offset={-10} position=\"insideBottomRight\" />\r\n                                    </XAxis>\r\n                                    <Legend formatter={this.renderLegendText} />\r\n                                    {/*TODO: COLOCAR LABEL CUSTOMIZADO COM A UNIDADE*/}\r\n                                    {this.state.dado1 != \"null\" && <YAxis yAxisId=\"left\"  label={{content: <UnitLabel/>, value: availablePlotOptions[this.mappedPlotingFields[this.state.dado1]].name+\" - [\"+availablePlotOptions[this.mappedPlotingFields[this.state.dado1]].unidade+\"]\", position: 'left', angle: -90 }}/>}\r\n                                    {this.state.dado2 != \"null\" && <YAxis yAxisId=\"right\" label={{content: <UnitLabel/>, value: availablePlotOptions[this.mappedPlotingFields[this.state.dado2]].name+\" - [\"+availablePlotOptions[this.mappedPlotingFields[this.state.dado2]].unidade+\"]\", position: 'right', angle: -90, offset: 50 }} orientation=\"right\"/>}\r\n                                    \r\n                                    {this.state.dado1 != \"null\" && <Line yAxisId=\"left\"  dot={<CustomDot/>} type=\"monotone\" dataKey={this.state.dado1} strokeWidth={2} isAnimationActive={false}/>}\r\n                                    {this.state.dado2 != \"null\" && <Line yAxisId=\"right\" dot={<CustomDot/>} type=\"monotone\" dataKey={this.state.dado2} strokeWidth={2} isAnimationActive={false} stroke=\"#008017\"/>}\r\n\r\n                                     \r\n                                </LineChart>\r\n                            </ResponsiveContainer>\r\n                        </div>\r\n                    </div>\r\n                </DelayProvider>\r\n            </div>\r\n        )\r\n    }\r\n\r\n    renderLegendText = (value) => {\r\n        return availablePlotOptions[this.mappedPlotingFields[value]].name;\r\n    }\r\n}\r\n\r\n\r\nfunction UnitLabel(props) {\r\n    // console.log(props);\r\n    const {viewBox, value, angle, offset} = props;\r\n    \r\n    // return (<div>{value}</div>);\r\n    return <text transform={\"rotate(\"+angle+\", \"+viewBox.x+\", \"+viewBox.y+\")\"} x={viewBox.x} y={viewBox.y} dx={-20} dy={10+offset} fill={\"whitesmoke\"} fontFamily=\"Exo\" fontSize=\"1rem\" textAnchor=\"end\">{value}</text>\r\n    \r\n}\r\n\r\nfunction CustomDot(props) {\r\n    const { cx, cy, stroke } = props;\r\n    return <circle cx={cx} cy={cy} r={3} stroke={stroke} strokeWidth={2} fill=\"whitesmoke\"/>\r\n}\r\n\r\nexport default Graficos;"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAGA;AAGA;AACA;AACA;AAGA;AAGA;AACA;AAEA;;;;;AAEA;AAAA;AACA;AADA;AACA;AAAA;AACA;AAFA;AAwcA;AACA;AACA;AAvcA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAnCA;AAkCA;AACA;;;;;;;;;;;AAEA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAAA;;;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAGA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAEA;;;AAKA;AAEA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAEA;AACA;AAIA;AACA;AAZA;AACA;AAYA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAIA;AAEA;AAEA;AACA;AAQA;AACA;AAIA;AACA;AAGA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AAEA;AACA;AAIA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AADA;AACA;AAGA;AAEA;AACA;;;AAIA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;;;AAEA;AACA;AACA;AAEA;AAAA;AACA;AADA;AAAA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;;AAEA;AACA;AACA;AAEA;AAEA;;;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AADA;AAMA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAUA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAUA;;;;AAvcA;AACA;AA8cA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;A","sourceRoot":""}